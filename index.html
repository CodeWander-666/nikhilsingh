<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NIKHIL SINGH | THE CYBER-MUSEUM</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; }
        
        /* Loading / Start Screen */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease-out;
        }
        
        .start-btn {
            background: transparent;
            color: #00f3ff;
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            border: 2px solid #00f3ff;
            padding: 20px 40px;
            text-transform: uppercase;
            letter-spacing: 5px;
            cursor: pointer;
            box-shadow: 0 0 20px #00f3ff;
            transition: 0.3s;
            animation: pulse 1.5s infinite;
        }
        .start-btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 50px #00f3ff; }

        @keyframes pulse { 0% { opacity: 0.8; box-shadow: 0 0 20px #00f3ff; } 50% { opacity: 1; box-shadow: 0 0 40px #00f3ff; } 100% { opacity: 0.8; box-shadow: 0 0 20px #00f3ff; } }

        /* The "HUD" is actually just a canvas overlay for interactions, visually invisible */
        #interaction-layer {
            position: absolute; bottom: 50px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.5); font-family: monospace; letter-spacing: 3px;
            pointer-events: none; opacity: 0; transition: opacity 2s;
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="color:white; font-family:sans-serif; letter-spacing:10px; font-weight:100; margin-bottom:50px;">NIKHIL SINGH</h1>
        <button class="start-btn" onclick="initExperience()">INITIALIZE SYSTEM</button>
        <p style="color:#555; margin-top:20px; font-family:monospace;">AUDIO REQUIRED // HIGH PERFORMANCE MODE</p>
    </div>

    <div id="interaction-layer">SCROLL TO TRAVEL TIME</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        // --- 1. AUDIO ENGINE (THX STYLE DEEP BASS) ---
        const AudioSys = {
            ctx: null,
            init: function() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            playDrone: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // Super Saw effect for "Cyber" sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, this.ctx.currentTime); // Deep Bass
                osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 5);
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 2); // Fade in
                
                // Lowpass Filter to make it muffled/cinematic
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.start();
                // Infinite drone
            },
            playSwoosh: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }
        };

        // --- 2. DATA (STORY) ---
        const timeline = [
            { id: 0, title: "THE BEGINNING", sub: "SCROLL TO START", z: 0, color: 0xffffff },
            { id: 1, title: "ALMABETTER", sub: "Full Stack Data Science (2025-Present)", z: -50, color: 0x00f3ff },
            { id: 2, title: "NOVUSFACE AI", sub: "DeepFake Engine // Python // PyTorch", z: -100, color: 0xff0055 },
            { id: 3, title: "SEOMAN AI", sub: "360 SEO Analyzer // Automation", z: -150, color: 0x00ff00 },
            { id: 4, title: "CERTIFIED", sub: "ChatGPT Expert // Be10x", z: -200, color: 0xffff00 },
            { id: 5, title: "CONTACT", sub: "LINKEDIN: Nikhil Singh", z: -250, color: 0xbc13fe }
        ];

        // --- 3. 3D ENGINE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- 4. ASSETS GENERATION (Procedural 3D Text) ---
        // Since we can't load external fonts easily without CORS, we use Canvas textures for text sprites
        function createTextSprite(text, color, size) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024; 
            canvas.height = 256;
            ctx.fillStyle = color;
            ctx.font = 'bold 80px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(text, 512, 128);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(size, size * 0.25, 1);
            return sprite;
        }

        // --- 5. BUILD THE WORLD ---
        
        // A. Infinite Tunnel
        const tunnelGeo = new THREE.CylinderGeometry(10, 10, 1000, 32, 100, true);
        const tunnelMat = new THREE.MeshBasicMaterial({ 
            color: 0x111111, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.1 
        });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        tunnel.rotation.x = -Math.PI / 2;
        tunnel.position.z = -250;
        scene.add(tunnel);

        // B. Timeline Markers
        const markers = [];
        timeline.forEach(item => {
            const group = new THREE.Group();
            group.position.set(0, 0, item.z);

            // Title
            const title = createTextSprite(item.title, '#' + item.color.toString(16), 20);
            title.position.y = 2;
            group.add(title);

            // Subtitle
            const sub = createTextSprite(item.sub, '#ffffff', 10);
            sub.position.y = 1;
            group.add(sub);

            // The "Artifact" (Visual Representation)
            const geo = new THREE.IcosahedronGeometry(1.5, 0);
            const mat = new THREE.MeshStandardMaterial({ 
                color: item.color, 
                emissive: item.color,
                emissiveIntensity: 0.5,
                roughness: 0.2,
                metalness: 0.8,
                wireframe: true
            });
            const mesh = new THREE.Mesh(geo, mat);
            group.add(mesh);
            
            // Rotating Rings
            const ringGeo = new THREE.TorusGeometry(3, 0.05, 16, 100);
            const ringMat = new THREE.MeshBasicMaterial({ color: item.color });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            group.add(ring);

            scene.add(group);
            markers.push({ group: group, mesh: mesh, ring: ring, z: item.z });
        });

        // C. Particle Starfield (Speed Lines)
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 5000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i<starsCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 200; // Spread wide
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({ size: 0.2, color: 0xffffff });
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);

        // --- 6. POST PROCESSING (GLOW) ---
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // High intensity
        bloomPass.radius = 0;
        composer.addPass(bloomPass);

        // --- 7. INTERACTION LOGIC (SCROLL TO FLY) ---
        let targetZ = 0;
        let currentZ = 0;
        let maxZ = (timeline.length - 1) * -50;
        
        window.addEventListener('wheel', (e) => {
            targetZ += e.deltaY * -0.1;
            // Clamp
            if(targetZ > 0) targetZ = 0;
            if(targetZ < maxZ) targetZ = maxZ;
        });

        // Touch support for mobile
        let touchStartY = 0;
        window.addEventListener('touchstart', e => touchStartY = e.touches[0].clientY);
        window.addEventListener('touchmove', e => {
            const deltaY = e.touches[0].clientY - touchStartY;
            targetZ += deltaY * 0.2;
            if(targetZ > 0) targetZ = 0;
            if(targetZ < maxZ) targetZ = maxZ;
            touchStartY = e.touches[0].clientY;
        });

        // --- 8. INITIALIZATION SEQUENCE ---
        window.initExperience = function() {
            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = 0;
            setTimeout(() => overlay.remove(), 1000);
            
            AudioSys.init();
            AudioSys.playDrone();
            
            // Camera Intro Animation
            camera.position.z = 100;
            gsap.to(camera.position, { z: 5, duration: 3, ease: "power2.out", onComplete: () => {
                document.getElementById('interaction-layer').style.opacity = 1;
            }});
        };

        // --- 9. ANIMATION LOOP ---
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Smooth Camera Movement
            currentZ += (targetZ - currentZ) * 0.05; // Lerp
            camera.position.z = currentZ + 10; // Camera trails slightly behind

            // Animate Markers
            markers.forEach((m, index) => {
                // Rotate Artifacts
                m.mesh.rotation.x += 0.01;
                m.mesh.rotation.y += 0.02;
                m.ring.rotation.x = Math.sin(time) * 0.5;
                m.ring.rotation.y = time * 0.5;

                // Scale effect based on proximity to camera
                const dist = Math.abs(currentZ - m.z);
                const scale = Math.max(0.5, 2 - (dist / 20)); // Grow when close
                m.group.scale.setScalar(scale);
                
                // Sound effect when passing a marker
                if(dist < 5 && !m.playedSound) {
                    AudioSys.playSwoosh();
                    m.playedSound = true; // Play once
                } else if (dist > 20) {
                    m.playedSound = false; // Reset
                }
            });

            // Warp Speed Effect on Stars
            const positions = starField.geometry.attributes.position.array;
            for(let i=2; i<positions.length; i+=3) {
                positions[i] += (currentZ - targetZ) * 0.5; // Stars move opposite to camera
                if(positions[i] > 100) positions[i] -= 400;
                if(positions[i] < -300) positions[i] += 400;
            }
            starField.geometry.attributes.position.needsUpdate = true;

            // Camera Shake based on speed
            const speed = Math.abs(targetZ - currentZ);
            camera.position.x = (Math.random() - 0.5) * speed * 0.01;
            camera.position.y = (Math.random() - 0.5) * speed * 0.01;

            composer.render();
        }
        animate();

        // Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
